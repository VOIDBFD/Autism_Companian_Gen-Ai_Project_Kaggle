# -*- coding: utf-8 -*-
"""Autism_Companion_AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GXuvSrysbP5IR7CeVRL4VJ_KEntbHoZD
"""

# Autism Companion: AI-powered assistive technology for children with ASD
# This code runs in Google Colab or Kaggle without requiring API keys

# Install necessary packages
!pip install -q transformers sentence-transformers faiss-cpu gradio datasets matplotlib torch huggingface_hub

# Import libraries
import os
import json
import time
import numpy as np
import pandas as pd
import torch
from datetime import datetime
import matplotlib.pyplot as plt
from sklearn.metrics.pairwise import cosine_similarity
import random

# For embeddings and vector search
from sentence_transformers import SentenceTransformer
import faiss
from datasets import load_dataset

# For LLM interaction
from transformers import (
    AutoTokenizer,
    AutoModelForCausalLM,
    pipeline
)

# For deployment
import gradio as gr

# ================================================================
# PART 1: DATA PREPARATION
# ================================================================

def generate_synthetic_asd_data():
    """Generate synthetic data for training and demonstration"""

    # Example social stories
    social_stories = [
        {
            "title": "Going to the Grocery Store",
            "content": "Today I am going to the grocery store with my mom. The store has bright lights and many people. If it gets too loud, I can put on my headphones. I can help by holding the shopping list. When we're done, we will go to the car and drive home.",
            "age_range": "4-6",
            "triggers": ["loud noises", "bright lights", "crowds"],
            "skills": ["shopping", "coping", "helping"]
        },
        {
            "title": "Taking Turns on the Swing",
            "content": "At the playground, there is one swing. Many children want to use it. I need to wait for my turn. I can count to 30 while someone else swings. Then it will be my turn. Waiting can be hard, but it makes everyone happy when we share.",
            "age_range": "5-7",
            "triggers": ["waiting", "playground noises"],
            "skills": ["turn-taking", "patience", "counting"]
        },
        {
            "title": "Making a New Friend",
            "content": "I see someone I want to be friends with. I can say 'Hi, my name is ___. What's your name?' I can ask what they like to play. If they answer, I can listen and then tell them what I like. If they don't want to talk, that's okay. I can try again another day.",
            "age_range": "6-8",
            "triggers": ["rejection", "social uncertainty"],
            "skills": ["greeting", "conversation", "resilience"]
        },
        {
            "title": "Calming Down When Upset",
            "content": "Sometimes I feel upset. My face gets hot. My heart beats fast. When this happens, I can take 3 deep breaths. I can count to 10 slowly. I can go to my quiet corner. When I feel calm, I can use my words to tell someone how I feel.",
            "age_range": "4-10",
            "triggers": ["emotional overwhelm", "sensory overload"],
            "skills": ["self-regulation", "emotional awareness", "communication"]
        },
        {
            "title": "Getting a Haircut",
            "content": "Today I am getting a haircut. The barber will use scissors to cut my hair. The scissors make a snipping sound. The barber might use clippers which buzz. They will brush away the hair that falls. It tickles a little. When they're done, my hair will be shorter and neater.",
            "age_range": "3-8",
            "triggers": ["buzzing sounds", "touch sensitivity", "unexpected movements"],
            "skills": ["grooming", "tolerance", "sitting still"]
        },
        {
            "title": "Eating Lunch at School",
            "content": "At lunchtime, I line up with my class. I get my lunch tray and find a seat. The cafeteria is noisy. Many children are talking. The food might smell strong. I will try to eat my lunch. If it's too noisy, I can ask to eat in a quieter place.",
            "age_range": "5-10",
            "triggers": ["loud noises", "strong smells", "crowded spaces"],
            "skills": ["eating", "self-advocacy", "following routines"]
        },
        {
            "title": "Riding the School Bus",
            "content": "I ride the school bus. I wait at the bus stop. When the bus comes, I get in line. I say hello to the bus driver. I sit in my seat and put on my seatbelt. The bus might be loud. I can wear my headphones or look out the window. When we get to school, I wait until the bus stops to stand up.",
            "age_range": "5-12",
            "triggers": ["loud noises", "crowded spaces", "transitions"],
            "skills": ["transportation", "safety", "following rules"]
        },
        {
            "title": "Playing a Board Game",
            "content": "Today I am playing a board game with my friend. First, we set up the game. Then we decide who goes first. I take my turn. Then I wait for my friend to take their turn. Sometimes I win, sometimes my friend wins. It's fun to play together even if I don't win.",
            "age_range": "6-10",
            "triggers": ["losing", "waiting", "rule changes"],
            "skills": ["turn-taking", "sportsmanship", "following rules"]
        }
    ]

    # Example visual schedules
    visual_schedules = [
        {
            "title": "Morning Routine",
            "steps": [
                "Wake up",
                "Use the bathroom",
                "Wash face and hands",
                "Get dressed",
                "Eat breakfast",
                "Brush teeth",
                "Pack backpack",
                "Put on shoes",
                "Go to school"
            ],
            "age_range": "4-10",
            "context": "home"
        },
        {
            "title": "Bedtime Routine",
            "steps": [
                "Take a bath",
                "Put on pajamas",
                "Brush teeth",
                "Read a story",
                "Say goodnight",
                "Turn off lights",
                "Go to sleep"
            ],
            "age_range": "3-8",
            "context": "home"
        },
        {
            "title": "School Day",
            "steps": [
                "Morning meeting",
                "Reading time",
                "Snack",
                "Math",
                "Lunch",
                "Recess",
                "Science",
                "Art",
                "Clean up",
                "Go home"
            ],
            "age_range": "5-12",
            "context": "school"
        }
    ]

    # Example therapy session logs (anonymized)
    therapy_logs = [
        {
            "session_id": "T001",
            "child_id": "C001",  # anonymized ID
            "age": 6,
            "session_goals": ["Turn-taking", "Emotion recognition", "Following instructions"],
            "activities": ["Card game", "Emotion flashcards", "Simon says"],
            "notes": "Child engaged well with emotion flashcards. Struggled with waiting for turns in card game. Responded to visual timer.",
            "progress": 3  # On scale of 1-5
        },
        {
            "session_id": "T002",
            "child_id": "C001",
            "age": 6,
            "session_goals": ["Turn-taking", "Emotion recognition", "Using indoor voice"],
            "activities": ["Board game", "Emotion scenarios", "Voice volume chart"],
            "notes": "Showed improvement in turn-taking with visual cue cards. Identified 4/6 emotions correctly. Needed frequent volume reminders.",
            "progress": 4
        },
        {
            "session_id": "T003",
            "child_id": "C002",
            "age": 8,
            "session_goals": ["Conversation skills", "Sensory regulation", "Fine motor skills"],
            "activities": ["Topic cards", "Sensory bin", "Bead stringing"],
            "notes": "Initiated conversation twice. Used squeeze ball appropriately when overwhelmed. Completed bead pattern with minimal assistance.",
            "progress": 4
        }
    ]

    data = {
        "social_stories": social_stories,
        "visual_schedules": visual_schedules,
        "therapy_logs": therapy_logs
    }

    # Save the data
    with open('autism_companion_data.json', 'w') as f:
        json.dump(data, f, indent=2)

    print("Synthetic data generated and saved.")
    return data

# ================================================================
# PART 2: EMBEDDING AND VECTOR SEARCH SYSTEM
# ================================================================

class EmbeddingEngine:
    """Handles embedding generation and vector search for therapy materials"""

    def __init__(self):
        # Initialize sentence transformer model
        self.model = SentenceTransformer('all-MiniLM-L6-v2')
        self.embeddings = None
        self.faiss_index = None
        self.documents = []

    def create_embeddings(self, data):
        """Create embeddings for all documents in the dataset"""
        print("Creating embeddings for therapy materials...")

        # Process social stories
        for story in data["social_stories"]:
            doc = {
                "type": "social_story",
                "title": story["title"],
                "content": story["content"],
                "age_range": story["age_range"],
                "triggers": story["triggers"],
                "skills": story["skills"]
            }
            self.documents.append(doc)

        # Process visual schedules
        for schedule in data["visual_schedules"]:
            doc = {
                "type": "visual_schedule",
                "title": schedule["title"],
                "content": " â€¢ ".join(schedule["steps"]),
                "age_range": schedule["age_range"],
                "context": schedule["context"]
            }
            self.documents.append(doc)

        # Create text representations for embedding
        texts = [f"{doc['title']}: {doc['content']}" for doc in self.documents]

        # Generate embeddings
        self.embeddings = self.model.encode(texts)

        # Create FAISS index
        dimension = self.embeddings.shape[1]
        self.faiss_index = faiss.IndexFlatL2(dimension)
        self.faiss_index.add(np.array(self.embeddings).astype('float32'))

        print(f"Created embeddings for {len(self.documents)} documents with dimension {dimension}")

    def search(self, query, k=3):
        """Search for most similar documents to the query"""
        query_embedding = self.model.encode([query])
        query_embedding = np.array(query_embedding).astype('float32')

        # Search the index
        distances, indices = self.faiss_index.search(query_embedding, k)

        # Return the top k most similar documents
        results = []
        for i, idx in enumerate(indices[0]):
            if idx < len(self.documents):
                doc = self.documents[idx].copy()
                doc["similarity_score"] = float(1 - distances[0][i]/100)  # Convert distance to similarity score
                results.append(doc)

        return results

    def detect_triggers(self, text, sensitivity=0.7):
        """Detect potential sensory triggers in generated content"""
        common_triggers = [
            "loud noise", "bright light", "strong smell", "crowded space",
            "unexpected touch", "flickering light", "sudden movement",
            "scratchy fabric", "food texture", "waiting in line"
        ]

        # Encode the text and triggers
        text_embedding = self.model.encode([text])[0]
        trigger_embeddings = self.model.encode(common_triggers)

        # Calculate similarities
        similarities = cosine_similarity([text_embedding], trigger_embeddings)[0]

        # Identify triggers above the sensitivity threshold
        detected_triggers = []
        for i, trigger in enumerate(common_triggers):
            if similarities[i] > sensitivity:
                detected_triggers.append({
                    "trigger": trigger,
                    "similarity": float(similarities[i])
                })

        return detected_triggers

# ================================================================
# PART 3: LOCAL LLM FOR TEXT GENERATION
# ================================================================

class LocalTextGenerator:
    """Generates text using local models without requiring API keys"""

    def __init__(self):
        # Load small, efficient local model
        print("Loading local text generation model...")
        model_name = "TinyLlama/TinyLlama-1.1B-Chat-v1.0"

        # Initialize tokenizer
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)

        # Set up pipeline for text generation
        self.generator = pipeline(
            "text-generation",
            model=model_name,
            torch_dtype=torch.float16 if torch.cuda.is_available() else torch.float32,
            device_map="auto",
            trust_remote_code=True
        )
        print("Local text generator ready.")

    def generate_text(self, prompt, max_length=500, temperature=0.7):
        """Generate text based on the provided prompt"""

        # Format for chat model
        formatted_prompt = f"<|user|>\n{prompt}\n<|assistant|>"

        try:
            output = self.generator(
                formatted_prompt,
                max_new_tokens=max_length,
                temperature=temperature,
                do_sample=True,
                top_p=0.95,
                top_k=50,
                repetition_penalty=1.2,
                pad_token_id=self.tokenizer.eos_token_id
            )

            # Extract generated text
            generated_text = output[0]['generated_text']

            # Remove the prompt from the output
            if formatted_prompt in generated_text:
                generated_text = generated_text.split("<|assistant|>")[1].strip()

            return generated_text

        except Exception as e:
            print(f"Error generating text: {e}")
            return self._get_fallback_response(prompt)

    def _get_fallback_response(self, prompt):
        """Return a fallback response if generation fails"""
        fallbacks = [
            "I'd like to help with that. Let me try to provide some information about this topic.",
            "This is an interesting topic. Here's what I can suggest based on best practices.",
            "I understand you're looking for assistance with this. Here are some thoughts that might help."
        ]
        return random.choice(fallbacks)

# ================================================================
# PART 4: SOCIAL STORY GENERATOR
# ================================================================

class SocialStoryGenerator:
    """Generates personalized social stories for children with ASD"""

    def __init__(self, text_generator=None):
        self.text_generator = text_generator
        self.templates = self._load_templates()

    def _load_templates(self):
        """Load templates for social stories"""
        templates = {
            "basic": """# Social Story: {scenario}

[IMAGE: Child looking at the situation]

My name is _____ and I am {age} years old.

Sometimes I need to {scenario}.

This can be difficult because _____.

When this happens, I can try to _____.

[IMAGE: Child using coping strategy]

It's okay to ask for help from _____.

I can say "_____" if I need a break.

[IMAGE: Child feeling proud]

When I {scenario}, I feel proud of myself!""",

            "emotions": """# Social Story: Feelings about {scenario}

[IMAGE: Child with different emotion faces]

When I {scenario}, I might feel different emotions.

I might feel happy because _____.

I might feel worried because _____.

If I feel worried, I can take deep breaths.

I can count: 1, 2, 3.

[IMAGE: Child taking deep breaths]

I can tell someone how I feel.

I can say "I feel _____."

My feelings are okay.

[IMAGE: Child calm and happy]

I can handle {scenario}!"""
        }
        return templates

    def generate_story(self, scenario, age, triggers=None, skills=None):
        """Generate a social story based on specific needs and parameters"""

        if not triggers:
            triggers = []
        if not skills:
            skills = []

        # If we have a text generator, use it
        if self.text_generator:
            # Build the system prompt
            system_prompt = """Create a social story for a child with autism.
            Social stories use clear, literal language without idioms or metaphors.
            Use first-person perspective.
            Include concrete descriptions of what happens and why.
            Include thoughts and feelings.
            Suggest coping strategies.
            Keep sentences short (7-10 words) and paragraphs brief.
            Be positive and reassuring."""

            # Build the user prompt
            user_prompt = f"{system_prompt}\n\nPlease create a social story about {scenario} for a {age}-year-old child."

            if triggers:
                user_prompt += f" The child is sensitive to these triggers: {', '.join(triggers)}."

            if skills:
                user_prompt += f" The story should help practice these skills: {', '.join(skills)}."

            user_prompt += " Include 3-5 [IMAGE] tags where visuals would be helpful."

            try:
                story = self.text_generator.generate_text(user_prompt, max_length=500)
                return story
            except:
                pass

        # If text generation fails or no generator is available, use templates
        if "emotion" in scenario.lower() or any(s.lower() in ["emotion", "feeling"] for s in skills):
            template = self.templates["emotions"]
        else:
            template = self.templates["basic"]

        # Fill in the template
        story = template.format(scenario=scenario, age=age)

        # Personalize for triggers if possible
        if triggers and len(triggers) > 0:
            trigger_text = f"I might notice {triggers[0]}."
            story = story.replace("This can be difficult because _____.",
                                 f"This can be difficult because {trigger_text}")

        # Personalize for skills if possible
        if skills and len(skills) > 0:
            skill_text = f"{skills[0]}"
            story = story.replace("When this happens, I can try to _____.",
                                 f"When this happens, I can try to practice {skill_text}.")

        return story

# ================================================================
# PART 5: VISUAL SCHEDULE GENERATOR
# ================================================================

class VisualScheduleGenerator:
    """Generates personalized visual schedules for children with ASD"""

    def __init__(self, text_generator=None):
        self.text_generator = text_generator
        self.schedule_templates = self._load_templates()

    def _load_templates(self):
        """Load templates for different types of schedules"""
        templates = {
            "morning": [
                "Wake up",
                "Use the bathroom",
                "Wash face",
                "Get dressed",
                "Eat breakfast",
                "Brush teeth",
                "Pack backpack",
                "Put on shoes",
                "Go to school/bus"
            ],
            "bedtime": [
                "Take a bath",
                "Put on pajamas",
                "Brush teeth",
                "Read a story",
                "Use the bathroom",
                "Say goodnight",
                "Turn off lights",
                "Go to sleep"
            ],
            "school": [
                "Arrive at school",
                "Morning meeting",
                "Reading time",
                "Snack",
                "Math",
                "Lunch",
                "Recess",
                "Special class",
                "Clean up",
                "Go home"
            ],
            "grocery": [
                "Make a list",
                "Drive to store",
                "Get a cart",
                "Find items",
                "Wait in line",
                "Pay cashier",
                "Bag groceries",
                "Go to car",
                "Drive home",
                "Put food away"
            ]
        }
        return templates

    def generate_schedule(self, activity, age, context=None, complexity=None):
        """Generate a visual schedule for a specific activity"""

        # Determine complexity level based on age if not specified
        if not complexity:
            if int(age) < 5:
                complexity = "simple"
            elif int(age) < 8:
                complexity = "moderate"
            else:
                complexity = "detailed"

        # If we have a text generator, try to use it
        if self.text_generator:
            system_prompt = """Create a visual schedule for a child with autism.
            Visual schedules help children understand routines through clear steps.
            Use action-oriented language (e.g., "Put on shoes" not "Get ready").
            Keep steps short (3-5 words each).
            Include visual cue markers [IMAGE] for each step."""

            user_prompt = f"{system_prompt}\n\nPlease create a {complexity} visual schedule for '{activity}' for a {age}-year-old child."

            if context:
                user_prompt += f" This will be used in the {context} context."

            user_prompt += " Create a numbered list of steps with [IMAGE] tags for each step."

            try:
                schedule = self.text_generator.generate_text(user_prompt, max_length=400)

                # Check if the generated schedule looks reasonable
                if schedule and "1." in schedule and "[IMAGE" in schedule:
                    return schedule
            except:
                pass

        # If text generation fails or no generator available, use templates
        template_key = None

        # Try to match the activity to a template
        activity_lower = activity.lower()
        if "morning" in activity_lower or "wake" in activity_lower:
            template_key = "morning"
        elif "bed" in activity_lower or "sleep" in activity_lower or "night" in activity_lower:
            template_key = "bedtime"
        elif "school" in activity_lower or "class" in activity_lower:
            template_key = "school"
        elif "grocery" in activity_lower or "shop" in activity_lower or "store" in activity_lower:
            template_key = "grocery"

        # Adjust number of steps based on complexity
        num_steps = 4 if complexity == "simple" else (6 if complexity == "moderate" else 8)

        # Build the schedule
        schedule = f"# Visual Schedule: {activity}\n\n"
        if template_key and template_key in self.schedule_templates:
            # Use the template
            steps = self.schedule_templates[template_key]
            # Adjust number of steps based on complexity
            if complexity == "simple":
                steps = steps[:4]  # Fewer steps for simple
            elif complexity == "moderate":
                steps = steps[:6]  # Medium number of steps

            # Add steps to schedule
            for i, step in enumerate(steps, 1):
                schedule += f"{i}. [IMAGE: {step}] {step}\n"

        else:
            # Generic schedule if no matching template
            schedule += "First, I think about what steps are involved:\n\n"
            schedule += f"1. [IMAGE: Start {activity}] Start {activity}\n"
            schedule += f"2. [IMAGE: First step] First step\n"
            schedule += f"3. [IMAGE: Middle step] Continue {activity}\n"
            if num_steps > 3:
                schedule += f"4. [IMAGE: Next step] Next step\n"
                if num_steps > 4:
                    schedule += f"5. [IMAGE: Almost done] Almost done\n"
                    if num_steps > 5:
                        schedule += f"6. [IMAGE: Final step] Final step\n"
            schedule += f"{num_steps+1}. [IMAGE: All done] All done! Great job!\n"

        return schedule

# ================================================================
# PART 6: ASD COMPANION AGENT
# ================================================================
class ASDCompanionAgent:
    """Implements an agent for interactive scenarios"""

    def __init__(self, embedding_engine, text_generator=None):
        self.embedding_engine = embedding_engine
        self.text_generator = text_generator
        self.child_profile = {}
        self.interaction_history = []
        self.response_templates = self._load_response_templates()

    def _load_response_templates(self):
        """Load templates for different types of responses"""
        templates = {
            "greeting": [
                "Hello there! I'm your autism companion. How can I help you today?",
                "Hi! I'm here to help with activities, schedules, or stories. What would you like?",
                "Welcome! I can help with social stories, schedules, or just chat. What do you need?"
            ],
            "unclear": [
                "I'm not sure I understand. Could you tell me more about what you need help with?",
                "I'd like to help you better. Can you explain what you're looking for?",
                "I want to make sure I help correctly. Could you give me more details about what you need?"
            ],
            "farewell": [
                "Goodbye! I'm here whenever you need help again.",
                "See you next time! Feel free to come back if you need more help.",
                "Bye for now! I'll be here when you need me again."
            ],
            "emotions": [
                "It sounds like you're feeling {emotion}. It's okay to feel that way.",
                "I understand that {emotion} feelings can be strong. Would you like to talk about it?",
                "When you feel {emotion}, what helps you feel better?"
            ],
            "story_request": [
                "I'd be happy to help with a story about {topic}. Let me create one for you.",
                "A story about {topic} sounds like a great idea. Here's one I think might help.",
                "I can create a social story about {topic}. Let me make one that would be helpful."
            ],
            "schedule_request": [
                "I can help create a schedule for {activity}. Let me make one that's clear and helpful.",
                "A visual schedule for {activity} is a great idea. Here's one I can suggest.",
                "I'll create a step-by-step schedule for {activity} that you can follow easily."
            ]
        }
        return templates

    def set_child_profile(self, profile):
        """Set information about the child to personalize interactions"""
        self.child_profile = profile
        print(f"Profile set for child: {profile.get('name', 'Anonymous')}, age {profile.get('age', 'unknown')}")

    def get_template_response(self, template_key, **kwargs):
        """Get a response from templates with formatting"""
        if template_key in self.response_templates:
            templates = self.response_templates[template_key]
            template = random.choice(templates)
            return template.format(**kwargs)
        return "I'm here to help. What would you like to do today?"

    def interact(self, user_input):
        """Process user input and generate an appropriate response"""

        # If profile isn't set, use default values
        if not self.child_profile:
            self.child_profile = {
                "name": "Alex",
                "age": 6,
                "triggers": ["loud noises", "unexpected changes"],
                "skills": ["turn-taking", "emotion recognition"],
                "communication_level": "moderate"
            }

        # Log the interaction
        self.interaction_history.append({
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "user_input": user_input,
        })

        # Check if this is a greeting
        greeting_words = ["hello", "hi", "hey", "greetings"]
        farewell_words = ["bye", "goodbye", "see you", "later"]

        # Process different types of inputs
        if any(word in user_input.lower() for word in greeting_words):
            response = self.get_template_response("greeting")

        elif any(word in user_input.lower() for word in farewell_words):
            response = self.get_template_response("farewell")

        # Check for story requests
        elif "story" in user_input.lower() or "social story" in user_input.lower():
            # Extract topic from request
            topic = user_input.lower().replace("story", "").replace("social", "").replace("about", "").strip()
            if not topic or len(topic) < 3:
                topic = "a common situation"

            # Create a personalized story
            story_generator = SocialStoryGenerator(self.text_generator)
            story = story_generator.generate_story(
                topic,
                self.child_profile.get("age", 6),
                self.child_profile.get("triggers", []),
                self.child_profile.get("skills", [])
            )

            response = f"Here's a social story about {topic}:\n\n{story}"

        # Check for schedule requests
        elif "schedule" in user_input.lower() or "routine" in user_input.lower() or "steps" in user_input.lower():
            # Extract activity from request
            activity = user_input.lower().replace("schedule", "").replace("routine", "").replace("steps", "").replace("for", "").strip()
            if not activity or len(activity) < 3:
                activity = "a daily activity"

            # Create a personalized schedule
            schedule_generator = VisualScheduleGenerator(self.text_generator)
            schedule = schedule_generator.generate_schedule(
                activity,
                self.child_profile.get("age", 6),
                self.child_profile.get("context", "home")
            )

            response = f"Here's a visual schedule for {activity}:\n\n{schedule}"

        # Check for emotion words
        elif any(emotion in user_input.lower() for emotion in ["happy", "sad", "angry", "scared", "worried", "excited", "calm", "upset"]):
            # Find which emotion was mentioned
            emotions = ["happy", "sad", "angry", "scared", "worried", "excited", "calm", "upset"]
            found_emotions = [e for e in emotions if e in user_input.lower()]

            if found_emotions:
                response = self.get_template_response("emotions", emotion=found_emotions[0])
            else:
                response = self.get_template_response("unclear")

        # Use text generator for other responses if available
        elif self.text_generator:
            # Create a prompt for the text generator
            system_context = f"""You are a specialized AI companion for children with autism spectrum disorder.
            Child Profile:
            Name: {self.child_profile.get('name', 'the child')}
            Age: {self.child_profile.get('age', 6)}
            Communication Level: {self.child_profile.get('communication_level', 'moderate')}

            Respond in a clear, supportive way that is appropriate for the child's age and communication level.
            Use short sentences and concrete language.
            Be positive and encouraging.
            """

            prompt = f"{system_context}\n\nChild or parent says: {user_input}\n\nYour response:"

            try:
                response = self.text_generator.generate_text(prompt, max_length=200)

                # Check if response is reasonable
                if not response or len(response) < 10:
                    response = self.get_template_response("unclear")
            except:
                response = self.get_template_response("unclear")
        else:
            # Fallback response
            response = self.get_template_response("unclear")

        # Check if the generated response might contain triggers
        try:
            response_triggers = self.embedding_engine.detect_triggers(response)

            if response_triggers:
                # Modify response to avoid triggers
                response = f"Note: This response might include content related to {response_triggers[0]['trigger']}.\n\n{response}"
        except Exception as e:
            # Handle any errors in trigger detection
            print(f"Error detecting triggers: {e}")

        # Log the response
        self.interaction_history[-1]["response"] = response

        return response
# ================================================================
# PART 7: PROGRESS TRACKING AND VISUALIZATION
# ================================================================

class ProgressTracker:
    """Tracks and visualizes progress over therapy sessions"""

    def __init__(self):
        self.sessions = []

    def add_session(self, session_data):
        """Add a therapy session data point"""
        if not isinstance(session_data, dict):
            raise ValueError("Session data must be a dictionary")

        required_fields = ["session_id", "date", "goals", "progress_ratings"]
        for field in required_fields:
            if field not in session_data:
                session_data[field] = "unknown" if field != "progress_ratings" else {}

        # Add timestamp if not present
        if "timestamp" not in session_data:
            session_data["timestamp"] = datetime.now()

        self.sessions.append(session_data)
        print(f"Added session {session_data['session_id']} to progress tracker")

    def get_progress_by_goal(self, goal, last_n=5):
        """Get progress data for a specific goal over the last n sessions"""
        relevant_sessions = [s for s in self.sessions if goal in s.get("goals", [])]
        relevant_sessions.sort(key=lambda x: x.get("timestamp", datetime.min))

        # Get the last n sessions
        recent_sessions = relevant_sessions[-last_n:] if last_n > 0 else relevant_sessions

        # Extract progress ratings for the goal
        progress_data = []
        for session in recent_sessions:
            if "progress_ratings" in session and goal in session["progress_ratings"]:
                progress_data.append({
                    "session_id": session["session_id"],
                    "date": session.get("date", "unknown"),
                    "rating": session["progress_ratings"][goal]
                })

        return progress_data

    def visualize_progress(self, goal=None, last_n=5):
        """Generate a visualization of progress"""
        plt.figure(figsize=(10, 6))

        if goal:
            # Visualize progress for specific goal
            progress_data = self.get_progress_by_goal(goal, last_n)
            if not progress_data:
                return "No progress data available for this goal."

            sessions = [d["session_id"] for d in progress_data]
            ratings = [d["rating"] for d in progress_data]

            plt.plot(sessions, ratings, marker='o', linestyle='-', linewidth=2)
            plt.title(f"Progress for Goal: {goal}")
            plt.xlabel("Session")
            plt.ylabel("Rating (1-5)")
            plt.grid(True)
            plt.ylim(0, 5.5)

        else:
            # Visualize overall progress across goals
            if not self.sessions:
                return "No session data available."

            # Get all unique goals
            all_goals = set()
            for session in self.sessions:
                all_goals.update(session.get("goals", []))

            # Get data for each goal
            goal_data = {}
            for goal in all_goals:
                progress_data = self.get_progress_by_goal(goal, last_n)
                if progress_data:
                    goal_data[goal] = {
                        "sessions": [d["session_id"] for d in progress_data],
                        "ratings": [d["rating"] for d in progress_data]
                    }

            # Plot each goal
            for goal, data in goal_data.items():
                plt.plot(data["sessions"], data["ratings"], marker='o', linestyle='-', label=goal)

            plt.title("Progress Across Goals")
            plt.xlabel("Session")
            plt.ylabel("Rating (1-5)")
            plt.legend()
            plt.grid(True)
            plt.ylim(0, 5.5)

        # Save the visualization
        plt.tight_layout()
        visualization_path = "progress_visualization.png"
        plt.savefig(visualization_path)
        plt.close()

        return visualization_path

# ================================================================
# PART 8: USER INTERFACE
# ================================================================

class ASDCompanionUI:
    """User interface for the ASD Companion application"""

    def __init__(self, agent, progress_tracker):
        self.agent = agent
        self.progress_tracker = progress_tracker
        self.interface = None

    def _setup_profile_tab(self):
        """Set up the child profile tab"""

        with gr.Tab("Child Profile"):
            gr.Markdown("# Child Profile")

            with gr.Row():
                with gr.Column():
                    name_input = gr.Textbox(label="Child's Name", placeholder="Enter child's name")
                    age_input = gr.Number(label="Age", minimum=2, maximum=18, value=6)
                    communication_level = gr.Dropdown(
                        label="Communication Level",
                        choices=["Minimal", "Moderate", "Advanced"],
                        value="Moderate"
                    )

                with gr.Column():
                    triggers_input = gr.Textbox(
                        label="Sensory Triggers (comma separated)",
                        placeholder="loud noises, bright lights, etc."
                    )
                    skills_input = gr.Textbox(
                        label="Skills to Practice (comma separated)",
                        placeholder="turn-taking, emotion recognition, etc."
                    )

            save_button = gr.Button("Save Profile")
            profile_message = gr.Textbox(label="Status", interactive=False)

            def save_profile(name, age, communication, triggers, skills):
                """Save the child profile"""
                profile = {
                    "name": name,
                    "age": int(age) if age else 6,
                    "communication_level": communication,
                    "triggers": [t.strip() for t in triggers.split(",") if t.strip()],
                    "skills": [s.strip() for s in skills.split(",") if s.strip()]
                }

                self.agent.set_child_profile(profile)
                return f"Profile saved for {name}!"

            save_button.click(
                save_profile,
                inputs=[name_input, age_input, communication_level, triggers_input, skills_input],
                outputs=[profile_message]
            )

            return [name_input, age_input, communication_level, triggers_input, skills_input]

    def _setup_interaction_tab(self):
        """Set up the interaction tab"""

        with gr.Tab("Companion"):
            gr.Markdown("# ASD Companion Chat")

            with gr.Row():
                with gr.Column(scale=2):
                    chat_history = gr.Chatbot(height=400)
                    message_input = gr.Textbox(
                        label="Type your message",
                        placeholder="Ask for a social story, schedule, or just chat...",
                        show_label=False
                    )
                    clear_button = gr.Button("Clear Chat")

                with gr.Column(scale=1):
                    gr.Markdown("### Quick Actions")
                    story_button = gr.Button("Create Social Story")
                    schedule_button = gr.Button("Create Visual Schedule")

                    gr.Markdown("### Topic")
                    topic_input = gr.Textbox(
                        label="Topic",
                        placeholder="going to the dentist, making friends, etc."
                    )

            def respond(message, history):
                """Process user message and get response"""
                if not message:
                    return "", history

                bot_response = self.agent.interact(message)
                history.append([message, bot_response])
                return "", history

            def create_story(topic, history):
                """Create a social story on a topic"""
                if not topic:
                    return history

                message = f"Please create a social story about {topic}"
                bot_response = self.agent.interact(message)
                history.append([message, bot_response])
                return history

            def create_schedule(topic, history):
                """Create a visual schedule for an activity"""
                if not topic:
                    return history

                message = f"Please create a visual schedule for {topic}"
                bot_response = self.agent.interact(message)
                history.append([message, bot_response])
                return history

            def clear_chat():
                """Clear the chat history"""
                return None

            message_input.submit(respond, [message_input, chat_history], [message_input, chat_history])
            story_button.click(create_story, [topic_input, chat_history], [chat_history])
            schedule_button.click(create_schedule, [topic_input, chat_history], [chat_history])
            clear_button.click(clear_chat, [], [chat_history])

            return [chat_history, message_input, topic_input]

    def _setup_progress_tab(self):
        """Set up the progress tracking tab"""

        with gr.Tab("Progress Tracking"):
            gr.Markdown("# Progress Tracking")

            with gr.Row():
                with gr.Column():
                    session_id = gr.Textbox(label="Session ID", placeholder="e.g., S001")
                    session_date = gr.Textbox(
                        label="Date",
                        placeholder="YYYY-MM-DD",
                        value=datetime.now().strftime("%Y-%m-%d")
                    )
                    goals = gr.CheckboxGroup(
                        label="Goals Addressed",
                        choices=[
                            "Turn-taking", "Emotion recognition", "Following instructions",
                            "Conversation skills", "Sensory regulation", "Social interactions",
                            "Transitions", "Self-regulation", "Communication"
                        ]
                    )

                with gr.Column():
                    gr.Markdown("### Progress Ratings (1-5)")
                    rating_boxes = {}
                    for goal in ["Turn-taking", "Emotion recognition", "Following instructions", "Conversation skills", "Sensory regulation"]:
                        rating_boxes[goal] = gr.Slider(
                            label=goal,
                            minimum=1,
                            maximum=5,
                            step=1,
                            value=3
                        )

            notes = gr.Textbox(
                label="Session Notes",
                placeholder="Enter notes about the session...",
                lines=3
            )

            save_session = gr.Button("Save Session")
            session_message = gr.Textbox(label="Status", interactive=False)

            # Visualization section
            gr.Markdown("## Progress Visualization")
            with gr.Row():
                with gr.Column():
                    goal_select = gr.Dropdown(
                        label="Select Goal to Visualize",
                        choices=["All Goals", "Turn-taking", "Emotion recognition",
                                "Following instructions", "Conversation skills",
                                "Sensory regulation"],
                        value="All Goals"
                    )
                    sessions_to_show = gr.Slider(
                        label="Number of Sessions to Show",
                        minimum=1,
                        maximum=10,
                        step=1,
                        value=5
                    )
                    visualize_button = gr.Button("Generate Visualization")

                with gr.Column():
                    visualization = gr.Image(label="Progress Chart")

            def save_session_data(session_id, date, selected_goals, notes, **ratings):
                """Save session data to progress tracker"""
                if not session_id or not selected_goals:
                    return "Please provide a session ID and select at least one goal."

                # Extract ratings for selected goals
                progress_ratings = {}
                for goal in selected_goals:
                    if goal in ratings:
                        progress_ratings[goal] = ratings[goal]

                # Create session data object
                session_data = {
                    "session_id": session_id,
                    "date": date,
                    "goals": selected_goals,
                    "notes": notes,
                    "progress_ratings": progress_ratings,
                    "timestamp": datetime.now()
                }

                # Add to progress tracker
                self.progress_tracker.add_session(session_data)

                return f"Session {session_id} saved successfully!"

            def generate_visualization(goal, n_sessions):
                """Generate progress visualization"""
                selected_goal = None if goal == "All Goals" else goal
                viz_path = self.progress_tracker.visualize_progress(goal=selected_goal, last_n=int(n_sessions))

                if isinstance(viz_path, str) and viz_path.endswith(".png"):
                    return viz_path
                else:
                    # If no visualization was created, return message
                    return None

            # Extract ratings from the UI components for all goals
            rating_inputs = {goal: box for goal, box in rating_boxes.items()}

            save_session.click(
                save_session_data,
                inputs=[session_id, session_date, goals, notes, *rating_inputs.values()],
                outputs=[session_message]
            )

            visualize_button.click(
                generate_visualization,
                inputs=[goal_select, sessions_to_show],
                outputs=[visualization]
            )

            return [session_id, session_date, goals, notes]

    def launch(self):
        """Launch the Gradio interface"""
        with gr.Blocks(title="Autism Companion") as self.interface:
            gr.Markdown("# Autism Companion")
            gr.Markdown("### AI-powered supportive tools for children with Autism Spectrum Disorder")

            profile_inputs = self._setup_profile_tab()
            chat_inputs = self._setup_interaction_tab()
            progress_inputs = self._setup_progress_tab()

            # About tab
            with gr.Tab("About"):
                gr.Markdown("""# About Autism Companion

                Autism Companion is an AI-powered tool designed to support children with Autism Spectrum Disorder (ASD) and their caregivers. This application provides personalized social stories, visual schedules, and interactive assistance to help children with ASD navigate daily situations and develop essential skills.

                ## Features

                - **Personalized Social Stories**: Create custom social stories for specific situations and challenges
                - **Visual Schedules**: Generate clear, visual step-by-step guides for daily activities
                - **Interactive Companion**: Chat-based interface for support and information
                - **Progress Tracking**: Monitor and visualize skill development over time

                ## How to Use

                1. Set up the child's profile in the "Child Profile" tab
                2. Use the "Companion" tab to chat with the AI or quickly generate materials
                3. Track progress and sessions in the "Progress Tracking" tab

                This is a prototype application and should be used alongside professional support, not as a replacement for therapy or medical advice.
                """)

        # Launch the interface
        self.interface.launch()

# ================================================================
# PART 9: MAIN APPLICATION
# ================================================================

def main():
    """Main application entry point"""
    print("Starting Autism Companion Application...")

    # Generate synthetic data for demonstration
    data = generate_synthetic_asd_data()

    # Initialize embedding engine
    embedding_engine = EmbeddingEngine()
    embedding_engine.create_embeddings(data)

    # Initialize text generator
    text_generator = LocalTextGenerator()

    # Initialize progress tracker
    progress_tracker = ProgressTracker()

    # Initialize ASD companion agent
    agent = ASDCompanionAgent(embedding_engine, text_generator)

    # Set up default child profile
    default_profile = {
        "name": "Alex",
        "age": 6,
        "communication_level": "Moderate",
        "triggers": ["loud noises", "bright lights", "unexpected changes"],
        "skills": ["turn-taking", "emotion recognition", "following instructions"]
    }
    agent.set_child_profile(default_profile)

    # Create and launch UI
    ui = ASDCompanionUI(agent, progress_tracker)
    ui.launch()

if __name__ == "__main__":
    main()